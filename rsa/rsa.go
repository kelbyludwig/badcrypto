package rsa

import (
	"crypto/rand"
	"crypto/sha1"
	"fmt"
	badbig "github.com/kelbyludwig/badcrypto/big"
	"math/big"
)

//PublicKey represents the public half of an RSA keypair.
type PublicKey struct {
	N *big.Int // Modulus
	E int64    //Public exponent
}

//PrivateKey represents the private half of an RSA keypair.
type PrivateKey struct {
	PublicKey *PublicKey
	D         *big.Int
	Primes    []*big.Int
}

//encryptNoPaddingMontgomery encrypts the supplied plaintext byte slice using the supplied public key.
//encryptNoPaddingMontgomery does not pad the plaintext prior to encryption and uses a non-blinded
//Montgomery exponentiation optimization which can leak information about the private key.
//extra is the number of "extra reductions" that were done over the exponentiation operation.
func encryptNoPaddingMontgomery(plaintext []byte, publicKey *PublicKey) (ciphertext []byte, extra int) {
	num := new(big.Int).SetBytes(plaintext)
	ct, extra := badbig.MontgomeryExp(num, big.NewInt(publicKey.E), publicKey.N)
	ciphertext = ct.Bytes()
	return
}

//SignPKCS1v15 signs plaintext with PKCS1v15 padding using SHA256
//as the underlying hash function. For simplicitys sake, the SHA256 hash
//is not encoding with the PKCS1v15 ASN encoding.
func SignPKCS1v15(plaintext []byte, privateKey *PrivateKey) (signature []byte) {

	digest := sha1.Sum(plaintext)
	digestLen := len(digest)
	//TIL: the stdlib's method of pkcs1v15 signing hardcodes asn der bytes for hash functions used in tls
	//https://golang.org/src/crypto/rsa/pkcs1v15.go#L205
	sha1Prefix := []byte{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14}
	prefixLen := len(sha1Prefix)
	pubLen := len(privateKey.PublicKey.N.Bytes())
	signature = make([]byte, pubLen)
	signature[0] = 0x00
	signature[1] = 0x01

	endpad := pubLen - prefixLen - digestLen
	for i := 2; i < endpad-1; i++ {
		signature[i] = 0xff
	}
	signature[endpad-1] = 0x00
	copy(signature[endpad:], sha1Prefix)
	copy(signature[endpad+prefixLen:], digest[:])
	signature = DecryptNoPadding(signature, privateKey)
	return

}

//verifyPKCS1v15Insecure will verify the validity of signatures generated by Sign.
//It is vulnerable to the signature forgery attack described by Bleichenbacher.
func verifyPKCS1v15Insecure(message []byte, signature []byte, publicKey *PublicKey) error {

	validationError := fmt.Errorf("invalid signature")
	blob := EncryptNoPadding(signature, publicKey)
	if blob[0] != 0x00 || blob[1] != 0x01 {
		return validationError
	}

	index := 2
	for {
		index += 1
		x := blob[index]
		if x == 0xff {
			continue
		}
		if x == 0x00 {
			break
		}
		return validationError
	}
	index += 1
	sha1Prefix := []byte{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14}
	prefixLen := len(sha1Prefix)
	if string(blob[index:index+prefixLen]) != string(sha1Prefix) {
		return validationError
	}
	index = index + prefixLen

	//assuming sha1
	hashLen := 20
	digest := sha1.Sum(message)
	if string(blob[index:index+hashLen]) != string(digest[:]) {
		return validationError
	}
	return nil
}

//EncryptNoPadding encrypts the supplied plaintext byte slice using the supplied public key.
//EncryptNoPadding does not pad the plaintext prior to encryption.
func EncryptNoPadding(plaintext []byte, publicKey *PublicKey) (ciphertext []byte) {
	num := new(big.Int).SetBytes(plaintext)
	ct := new(big.Int).Exp(num, big.NewInt(publicKey.E), publicKey.N)
	ciphertext = ct.Bytes()
	if len(ciphertext) != len(publicKey.N.Bytes()) {
		ciphertext = append([]byte{0}, ciphertext...)
	}
	return
}

//decryptNoPaddingMontgomery decrypts the supplied ciphertext using the supplied PrivateKey.
//decryptNoPaddingMontgomery does not validate or strip off any form of padding and uses a non-blinded
//Montgomery exponentiation optimization which can leak information about the private key.
//extra is the number of "extra reductions" that were done over the exponentiation operation.
func decryptNoPaddingMontgomery(ciphertext []byte, privateKey *PrivateKey) (plaintext []byte, extra int) {
	num := new(big.Int).SetBytes(ciphertext)
	N := privateKey.PublicKey.N
	pt, extra := badbig.MontgomeryExp(num, privateKey.D, N)
	plaintext = pt.Bytes()
	if len(plaintext) != len(N.Bytes()) {
		plaintext = append([]byte{0}, plaintext...)
	}
	return
}

//DecryptNoPadding decrypts the supplied ciphertext using the supplied PrivateKey.
//DecryptNoPadding does not validate or strip off any form of padding.
func DecryptNoPadding(ciphertext []byte, privateKey *PrivateKey) (plaintext []byte) {
	num := new(big.Int).SetBytes(ciphertext)
	N := privateKey.PublicKey.N
	pt := new(big.Int).Exp(num, privateKey.D, N)
	plaintext = pt.Bytes()
	for len(plaintext) < len(N.Bytes()) {
		plaintext = append([]byte{0}, plaintext...)
	}
	return
}

//GenerateKey generates an RSA private key (and corresponding public key)
//given the size of a modulus in bits.
func GenerateKey(bits int) (priv *PrivateKey, err error) {

	if bits%2 != 0 {
		err = fmt.Errorf("bits must be a multiple of 2")
		return
	}

	pub := new(PublicKey)
	pub.E = 3

	priv = new(PrivateKey)
	priv.Primes = make([]*big.Int, 2)

	for {
		p, err1 := rand.Prime(rand.Reader, bits)
		q, err2 := rand.Prime(rand.Reader, bits)

		if err1 != nil || err2 != nil {
			err = fmt.Errorf("unable to generate prime numbers")
			return
		}

		priv.Primes[0] = p
		priv.Primes[1] = q

		totient1 := new(big.Int).Sub(p, big.NewInt(1))
		totient2 := new(big.Int).Sub(q, big.NewInt(1))
		totient := new(big.Int).Mul(totient1, totient2)

		gcd := new(big.Int).GCD(nil, nil, totient, big.NewInt((pub.E)))
		if gcd.Cmp(big.NewInt(1)) == 0 {
			pub.N = new(big.Int).Mul(p, q)
			priv.D = new(big.Int).ModInverse(big.NewInt(int64(pub.E)), totient)
			break
		}
	}

	priv.PublicKey = pub
	return

}

//ChineseRemainderTheorem solves a set of congruences of the form:
//  x = a1 (mod m1)
//  x = a2 (mod m2)
//  ...
//  x = an (mod mn)
//ChineseRemainderTheorem takes the set of ai and mi as input and returns x.
func ChineseRemainderTheorem(as, ms []*big.Int) (*big.Int, error) {

	if len(as) != len(ms) {
		return big.NewInt(0), fmt.Errorf("lists provided were unequal in lenght")
	}

	M := big.NewInt(1)
	for _, m := range ms {
		gcd := new(big.Int).GCD(nil, nil, M, m)
		if gcd.Cmp(big.NewInt(1)) != 0 {
			return big.NewInt(0), fmt.Errorf("moduli were not comprime")
		}
		M = M.Mul(M, m)
	}

	result := big.NewInt(0)
	for i, a := range as {
		b := new(big.Int).Div(M, ms[i])
		bi := new(big.Int).ModInverse(b, ms[i])
		mul := new(big.Int).Mul(b, bi)
		mul = mul.Mod(mul, M)
		mul = mul.Mul(mul, a)
		mul = mul.Mod(mul, M)
		result = result.Add(result, mul)
	}
	result = result.Mod(result, M)
	return result, nil
}

//BigIntCubeRootFloor computes the floor of the cube root of a positive integer.
//The algorithm is described here: http://math.stackexchange.com/a/263113
func BigIntCubeRootFloor(n *big.Int) *big.Int {
	THREE := big.NewInt(3)
	cube, x := new(big.Int), new(big.Int)

	a := new(big.Int).Set(n)
	for cube.Exp(a, THREE, nil).Cmp(n) > 0 {
		x.Quo(n, x.Mul(a, a))
		x.Add(x.Add(x, a), a)
		a.Quo(x, THREE)
	}

	return a
}
